# 第五章 端到端传输

[toc]

> 网络层及下层技术实现主机到主机通信（无连接、尽最大努力交付）
> 传输层使主机端实现可靠传输（按序）、多应用进程、流量控制、消息任意长度、拥塞控制
> 上述多应用用UDP，其他用TCP

## 传输层协议概述

- 进程间端到端，是面向通信部分最高层，面向用户部分最底层
- 仅有端系统使用，向应用层服务（包括middlebox等特殊网络设备）

### 传输端口与多路分解/复用

- 前提是应用进程的标识
  - 对不同操作系统兼容，利用目的主机功能识别终点而不关心进程
  - 抽象定位符**端口**，**间接**沟通进程
  - 源端口是起点，目的端口是终点
- 端口
  - 传输端口是抽象的软件端口，进程与传输实体交互的地址
  - 消息队列管理端口
  - 16位整数标识，区分**本计算机**的进程
  - UDP用二元组标识，TCP用四元组标识（前者无连接）
  - 客户端发起请求，服务器应答客户进程的端口号
- 端口分类：
  - 熟知端口 0~1023 一般作为通信起点，后续更换端口通信以释放给其他进程
  - 登记端口号 1024~49151 服务提供商使用
  - 客户端端口 49152~65535

## 用户数据报协议UDP

- 最简单的传输协议
- 端到端、尽力而为的、**面向非连接**的（数据包）传输服务
- 把下层传递服务扩展到进程到进程，多路分解与复用
- 只是在IP数据报服务上增加了多路分解/复用（端口）功能及差错检测
- 特点
  - 无连接，无需维护，故开销小，启动延迟短，如DNS
  - 不保证可靠传输，故不需维持复杂状态
  - 无拥塞控制，适合IP电话、视频直播等要求恒定发送速率、允许丢包但时延敏感的应用
  - 支持一对多、多对一、一对一、多对多，可以建立组播应用
  - 面向报文
    - 不合并不拆分，增删UDP首部后直接交付IP层
    - 每次都交付发送或接收一个完整的报文
    - *要求应用程序选择大小合适的报文*
  - 上层应用可以建立更多功能，如UDT
    - 增加拥塞控制和可靠传输控制，但不必像TCP那么复杂
    - 支持高速广域网的海量数据传输（TCP再高带宽长距离网络上性能差）
- 首部格式：源端口+目的端口+长度+校验和
  - 源端口：无需回复时置0
  - 目的端口：不正确时回复ICMP端口不可达差错报文，如traceroute用非法UDP端口识别目的主机
  - 长度：最小值为8，包括首部
  - 校验和：计算前加上伪首部（从IP头提取源IP地址、目的IP地址、0、17、UDP长度），避免中间节点的篡改、分组传递错误，以在正确的两个端点间传播
  - 二进制反码求和后取反码

## 传输控制协议TCP

- 端到端、可靠的、**面向连接**的**字节流**服务
- 多路分解与复用，包括实现连接管理、可靠传输、流量控制、拥塞控制
- 面向连接：通信双方先建立逻辑连接，再进行双向数据流传输，通信结束撤销连接
- 点对点双工通信：两端都有收发的字节缓存
- 可靠传输：对传输的每个字节编号，通过接收确认和重传保证可靠传输
- 流量控制：防止发送数据超出接收方能力
- 拥塞控制：防止注入网络数据过多造成节点或链路超载
- 演进历史：两端传输策略、扩展选项、标准头部；向后兼容；适应不同网络环境和提升传输性能
- 核心是滑动窗口算法：可靠和有序控制、流量控制、自适应重传、拥塞控制

### TCP报文段格式

- 20字节固定首部 + 可变长度选项
- 2字节源端口和2字节目的端口：实现多路复用
- 4字节序号：每一个字节的序号
- 4字节确认号：期待收到的下一序号，即最大已接收序列号+1
- 4bit数据偏移：即头部长度，单位为32bit（4字节），最大值为40（头部最大为60字节）
- 6bit标志字段
  - URG 紧急：置1时紧急指针有效，指明非紧急数据起始（之前是紧急数据）
  - ACK 确认：置1时确认号字段有效
  - PSH 推送：置1时表示发送方调用push操作，表示应尽快交付
  - RST 复位：置1时表示TCP连接出现严重差错，需要释放连接并重新建立；或拒绝非法报文段和打开连接
  - SYN 同步：置1时表示连接请求/接受报文，用于建立连接
    - ACK=0为连接请求，ACK=1为连接接受
  - FIN 终止：释放连接，表明数据发送完毕，要求释放TCP连接
- 2字节接收窗口：再滑动窗口算法中控制流量，指明发送者接收窗口大小，指示对端设置发送窗口
- 2字节校验和
- 最大40字节选项，包括最搭报文段长度MSS；窗口扩大选项；时间戳选项；选择确认选项（ACK为连续确认，本选项为间隔确认）
- SYN/FIM/ACK/序号/确认号实现连接管理
- ACK/确认号/选项实现可靠传输
- 接收窗口/选项实现流量控制
- 协议格式中未体现拥塞控制
- **SYN=1的报文段不携带数据，但消耗掉一个序号**

### 连接管理

- TCP连接是一对双向的点对点字节流，两个端点（套接字socket）的组合，IP和端口的四元组
- 三个阶段：建立连接、数据传输、释放连接
- TCP传输总需要确认，最后一次确认用时间实现
- SYN/FIN包均占用序号
- 报文段丢失时需要重传机制

#### 连接建立

- 确定初始序列号
  - 两端相互独立随机选择，防止同一连接标识的不同实例过快重复使用同一序号（但是由于端口不同，问题不大）
- 允许协商最大报文长度、最大窗口大小等参数
- 分配缓存大小等传输实体资源
- 客户端主动发起，协议栈随机产生端口号
- 服务器预先被打开，创建传输控制块，并进入listen状态
- 三次握手
  1. 两端都在CLOSED状态
  2. 服务器打开到LISTEN状态，客户端主动打开到SYN-SENT状态，发送SYN=1，seq=x的报文
  3. 服务器进入到SYN-RCVD状态，回复SYN=ACK=1，seq=y，ack=x+1的报文
  4. 客户端进入到ESTABLISHED状态，回复SYN=0，ACK=1，seq=x+1，ack=y+1的报文，可携带数据
  5. 服务器进入到ESTABLISHED状态
- 三次握手中客户端的最后一个确认报文是为防止“已失效的连接请求报文”又传输到服务器而出错
  - 客户端的第一个连接请求未丢失且服务器未及时收到，则必须要有第三次握手，否则服务器会单方面建立连接，浪费资源
  - 一定程度上缓解syn-flooding攻击

#### 数据传输

- 每个字节顺序编号，报文段序列号指本报文段发送的首字节序号
- 接收方应答接收确认、接收窗口大小
- 传输基于滑动窗口算法
  - **触发传输**决定何时发送
  - **自适应重传**决定丢包检测和重传
  - **流量控制**使发送速率不超过接收能力
  - **拥塞控制**尽可能多利用网络带宽

#### 连接释放

- 包括FIN/RST两种方式，需要考虑释放时机，保证完全释放
- 连接**任何一方**都可以**主动**关闭连接，通过发送FIN报文表示己方不再发送数据
- 另一端可继续发送数据，且仍需要接收方的确认报文段
- 异常情况下，任何一方都可以发送RST报文段关闭连接：一键清零
- 四次挥手
  1. 客户端传输结束主动关闭连接，发送FIN=1，seq=u的报文，进入到FIN-WAIT-1状态。u为已传输数据末字节+1，FIN报文消耗一个序号
  2. 服务器进入CLOSE-WAIT状态，回复ACK=1，seq=v，ack=u+1的报文（服务器到客户端连接未关闭）
  3. 客户端进入FIN-WAIT-2状态，服务器发送完毕后通知应用进程，被动关闭连接，进入LAST-ACK状态，发送FIN=ACK=1，seq=w，ack=u+1的报文
  4. 客户端进入TIME-WAIT状态，回复ACK=1，seq=u+1，ack=w+1的报文
  5. 服务器撤销传输控制块TCB，进入CLOSED状态；若未收到，超时重传上一步的报文
  6. 客户端等待2*MSL（最长报文段寿命）后进入CLOSED状态；若收到重传报文段，重置计时
    - 目的在于保证最后一个ACK报文段能到达服务器，且防止已失效的连接请求报文段出现在本连接中
- 发送RESET关闭连接的情况：
  - 请求连接不存在的端口
  - 某端TCP出现混乱情况
  - 某端TCP发现对端TCP空闲时间超长

### 可靠和有序传输

#### 滑动窗口算法

- 通过**超时**和**重传**保证数据可靠传输
- 通过字节流序号保证数据有序传输
- 增强发送方对接收方的流量控制
- 实现网络拥塞控制
- 发送方的TCP
  - 维护一个发送缓冲区（包括未发送和未确认的数据），维护三个指针：最后一个已确认字节≤最后一个已发送字节≤最后一个写入字节
  - 发送窗口上限值 = min（拥塞窗口，对端接收窗口）
  - 有效窗口AdervisedWindow = 发送窗口上限值 - 已发送未确认长度（最后发送字节序号 - 最后确认字节序号）
- 接收方的TCP
  - 维护一个接收缓冲区（包括未读出和未确认的数据），维护三个指针：最后一个已读出字节＜下一个希望收到字节（第一个连续已确认段后）≤最后一个收到字节
  - 接收窗口 = 缓冲区长度 - 已确认未读出长度（最后一个**连续已确认**字节序号 - 最后一个已读出字节序号）
- 累积确认：对按序到达的最后一个报文段确认
- 选择确认SACK：确认接收到的不连续的数据块的边界
  - 使用首部的SACK选项，不影响ACK字段

### 流量控制

- 目的是防止快发送方给慢接收方发数据造成接收缓冲区溢出的崩溃
- 接收方根据缓存大小确定接收窗口大小，并通知发送方；发送方保证发送窗口小于接收窗口大小
- 接收窗口大小：保持最后收到字节 - 最后读出字节 ＜ 缓冲区长度，即 接收窗口 = 缓冲区长度 - 已确认未读出长度（最后一个**连续已确认**字节序号 - 最后一个已读出字节序号）
- 发送方收到确认后，最后确认字节序号增加，但不保证有效窗口增大。因为有效窗口受限于对端窗口，对端若没有读出，则对应到发送方也不能增大发送窗口；发送缓存也不能溢出，即 已发送未确认 + 已写入未发送 ＜ 缓冲区长度
- 接收方读取速率小于数据到达速率时，报文段到达使得有效窗口减小，直至归0，此时不再发送任何数据，直至发送缓冲区因为进程写入而被填满，进而阻塞，直至接收方读取数据使有效窗口增加
- **TCP仅在有数据或有确认需要向对端发送时才会发送报文段，并捎带接收窗口大小**
- 当接收窗口归零后，即使重新有了空间，也没有机会触发通知，引起死锁
  - 解决方案是发送方主动定期探测，收到0窗口通知后启动计时器，每个周期发送1字节数据的0窗口探测报文
  - TCP设计原则：接收方尽可能简单
- 长肥管道现象：对于往返时间长，时延带宽积较大的通路（长肥管道），窗口小会导致在途数据量很少，降低交互效率
  - 解决方法：通过**窗口扩大选项**匹配大时延带宽积。定义了扩展因子/移位计数，最大偏移为14

### 触发传输

- 包括3种基本触发机制
- 数量驱动：TCP维护**最大报文段长度MSS**（一般设置为TCP能发送且不造成本地IP分段的最大长度），缓冲区数据达到MSS字节时，组装TCP报文段并发送
- 事件驱动：进程要求时TCP进行推送操作（PUSH）
- 时间驱动：计时器到期时把缓存区所有数据装入报文段发送
- 考虑窗口限制，当窗口小于MSS时，如果一味利用任何可用窗口，会导致**糊涂窗口综合征**：小报文段充满网络，传输效率低
  - 根本原因：接收方打开小窗口、发送方传送小报文段（无法禁止，因为存在push操作）
  - 解决：等待至窗口大于MSS或缓存区一半再发送确认
  - 等待时间太长不利于telnet等交互式应用，太短依然会导致糊涂窗口综合征
- Nagle算法
  - 窗口小于MSS时，发送方等待一段时间；在发送窗口≥MSS或数据达到发送窗口一半大小时发送（数量驱动）
  - 引入自计时定时器，收到接收方ACK后激活（事件驱动）
  - 不满足上述发送条件时，若处于活跃状态（有报文在传输或未确认），则缓存新字节直至收到ACK；若非活跃，无报文在传输，则发送缓存中所有数据（小报文段）

### 自适应重传

- TCP每发送一个报文段，就设置一个定时器。达到超时重传时间RTO后，若还没有确认，则重传报文段
- 由于IP选择路由不稳定，同一节点不同TCP的RTT差异可能很大，且同一TCP连接的RTT在不同时间有变化，所以RTO很难给定
  - 设置过长使得丢包效率低，设置过短导致误重传
- 原始算法
  - 维持RTT平均运行值（ERTT），乘2得到RTO
  - 对每次发送报文到收到ACK的差值（SRTT）和ERTT计算加权平均，得到新的ERTT
  - ERTT(new) = (1-a)*ERTT(old) + a*SRTT
  - 原始TCP规范建议a取值0.8~0.9，过小不能迅速适应变化，过大受瞬时波动影响大
  - 缺陷：ACK对接收数据而非报文段，若被重传过，无法确定时针对原始报文段还是重传报文段，故无法正确计算SRTT
- Karn/Partridge算法
  - 超时重传时停止计算SRTT
  - 超时重传后直接将RTO设为k（一般为2）倍
    - 指数回退算法：丢包最大原因是拥塞，避免TCP对超时反应太主动，缓解拥塞
  - 直至不再发生重传，根据SRTT重新计算RTO
- Jacobson/Karels算法
  - RTO应同时反映RTT和RTT的变化
  - RTO = ERTT + 4 * RTTD
  - ERTT = (1 - a) * ERTT + a * SRTT
    - a推荐值1/8
  - RTTD = (1 - t) * RTTD + t * |ERTT - SRTT|
    - t推荐值1/4
  - 变化小时RTO更接近ERTT，变化大时RTTD决定计算结果

#### 快速重传

- 粗粒度（RTO）的实现方法导致效率低
- 快速重传的基本思想：重复确认触发重传
  - 报文段到达接收方后立刻回复ACK确认当前应确认的序号，即使已确认过（重复确认）
  - 发送方收到重复ACK若干次（实际为3）后（可能是丢失或延迟），立即触发重传
  - 通常在一个RTT内重传数据丢包（因为数据包通常连续发送，故包间隔远小于RTT），使网络吞吐量提高20%
  - 超时重传不能替代重传定时器，只在某些情况下更早触发重传丢失的报文段
- 时间戳（timestamp）选项
  - 发送方写入发送时刻时钟值，接收方拷贝该值。所以发送方回收ACK时可以相减得到RTT
  - 不需两端时钟同步，更细粒度计算RTT

### 拥塞控制

- 端系统速率应让接收方和网络均可承受，即流量控制和拥塞控制
- 负载达到knee点后吞吐率增长放缓，延迟增长加速；cliff点后吞吐量下降到0，延迟增加到无限大
- 多个流共享网络内资源（不知道网络状况和其他流状况）
- **实时检测并干预**
  - 发送速率适应网络瓶颈（静态能力）
  - 发送速率适应网络处理能力变化（动态状态）
  - 多条流**公平**共享资源

#### 拥塞原因

> 当分组到达速率接近链路容量时，分组的排队时延会急剧增大（cache无穷大的理想状态下）

1. 两个主机AB和缓存无穷大路由器，连接AC和BD共享单跳路由，链路容量为R
  - 当发送速率超过R/2时，吞吐量保持在R/2，平均时延随发送速率接近R/2趋向无限大
2. 两个主机AB和有限缓存路由器（分组到达已满缓存时会被丢弃），连接AC和BD共享单跳路由，链路容量为R
   1. 发送方若能以某种方式确定路由器缓存，空闲时才发送分组，则无丢包无重传，吞吐量 = 发送速率（不超过R/2）
   2. 【发送角度重传代价】发送发确定分组丢失时重传（重传不及时），平均1/3是重传数据，吞吐率只能达到发送速率的2/3（执行重传补偿缓存溢出丢包）
   3. 【发送角度重传代价】发送方提前检测超时并重传已推迟但未必丢失的分组（非必要提前重传），对转发分组是浪费，吞吐率只能达到发送速率的1/2（大时延引起不必要重传浪费链路资源）
3. 4台发送主机分为两对，每对用两跳路径传输，共4台有限缓存路由器
  - 发送速率较小时，溢出情况很少，吞吐量约等于发送速率
  - 发送速率较大时，一个路由器同时作为一条链路的上游和另一链路下游，前者发送速率受上游限制为R，后者可以不断增大，导致前者竞争得到的缓存空间、继而是吞吐量，均趋于0；四个路由器均为如此
  - 结论：当一个分组被丢弃时，每个上游路由器用于转发该分组的传输容量都被浪费

#### 拥塞控制思路

- 端到端的拥塞控制（TCP策略）
  - 通过丢包、延迟变化等推测网络拥塞
  - 网络中间设备设计简单
  - 拥塞推断策略不准确
- 网络辅助的拥塞控制
  - 网络设备提供反馈（规定发送速率ATM，拥塞标志位ECN（TCP/IP扩展功能））
  - 资源利用率高
  - 中间设备设计复杂，每条流维护一个状态，可扩展性差

#### TCP拥塞控制

- 改变发送窗口大小控制发送速率，拥塞控制算法决定拥塞窗口cwnd
- 慢启动和拥塞避免和快重传和快恢复

##### 拥塞检测

- 丢包进行隐式反馈（网络无关的端到端）
- ACK判断丢包
- 判断拥塞的两个依据
  - 报文段超时（不是唯一原因，但几乎百分百）
  - 收到多个重复ACK（到达报文段乱序）

##### 拥塞窗口调整

- 初始建立时找到适应可用资源的发送速率
- 过程中调整发送速率
- 使共享资源的流获得相对公平的服务
- 基本思想
  - 网络拥塞时减慢发送速率，收到新的非重复ACK时增大发送速率
  - 初始建立时找到适应可用资源的发送速率【慢启动】
  - 过程中调整发送速率【拥塞避免】
  - 使共享资源的流获得相对公平的服务【拥塞避免】

###### 慢启动

- 连接刚建立时不确定网络状况，应避免注入大量数据引起拥塞
- 拥塞窗口从很小的初值开始，成功则快速增大，探测网络负载能力
- cwnd初始值设置为2~4个发送方最大报文段SMSS
- 每收到一个对新报文段的确认，cwnd增加1个SMSS的大小（由于连续发送时间远小于RTT，可视为指数级增长）
- 慢启动的问题
  - 快速增长到一定值会导致大量丢包

###### 拥塞窗口的增减策略

- 加性增减A和乘性增减M
- 缓和增大、急剧减小较为合理（AIMD）：x+1和x/2，即拥塞避免
- 收到对新报文段确认后，cwnd += 1MSS / cwnd（每个轮次++）
- 系统中引入慢启动门限值ssthresh，当cwnd小于该值使用慢启动，大于时改用AIMD
- 超时时门限值减半，cwnd置为最小值，重新慢启动

###### 快重传与快恢复

- 快恢复：快重传后直接减半ssthresh，并减半cwnd（不是从1开始），再执行拥塞避免（AIMD）
- 并非取消慢启动（超时时要慢启动，虽然概率不高），只是针对收到多个ACK的快重传的优化
- 无归零，减少慢启动，减少超时等待引起的连接无效（cwnd不变且无数据发送）时间；可以达到在最优值附近摆动的稳态

#### 网络中间设备对TCP性能影响

- Buffer大小（过大时引起bufferbloat问题）
- 队列调度（先进先出FIFO/公平排队）
- 丢弃策略（队尾丢弃TailDrop/随机早检测RED）
- 通常采用FIFO+TailDrop，存在问题
  - 浪费带宽：尾部丢弃导致一连串分组丢失，使数据发送速率骤减
  - 全局同步：同时影响多条TCP连接，使之同时都进入慢启动（由于慢启动，全网通信量突减又突增）

##### 随机早检测RED

- 主动队列管理AQM：提前预警和处理（拥塞征兆）
- 队列维护最小门限和最大门限
- 分组到达时先计算平均队列长度L
  - L小于最小门限时丢弃概率为0，放入队列排队
  - L大于最大门限时丢弃概率为1，直接丢弃新到达分组
  - L在两个门限之间，则以p=f(L)概率丢弃分组（避免全局同步）
- 使用效果不理想，未大规模部署
